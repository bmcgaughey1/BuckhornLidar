# Use a brute force methods to add simple height measurements from CHM and point
# cloud using the perfect tree grid (not lidar-derived trees) that has NOT been 
# adjusted to better align with the lidar-derived trees.
#
# ******
# You can't directly compare the heights generated by this code with heights
# for adjusted trees.
#
# uses smoothed and non-smoothed CHMs. In general, the smoothed CHM heights
# will be lower than the non-smoothed heights. However, since the tree locations
# are based on the theoretical grid, tree locations may not correspond to a local 
# maxima (or high point on the CHM). It is possible for heights from the smoothed
# CHM to be higher than those from the non-smoothed.
#
source("Rcode/FileSystem.R")
library(terra)
library(fusionwrapr)

# set up some things for FUSION commands
inputFolder <- paste0(dataFolder, "StemMaps/")
outputFolder <- paste0(dataFolder, "FINALData/")

# make sure output folder exists
if (!dir.exists(outputFolder)) {dir.create(outputFolder)}

# set the search radius for the high point closest to each grid tree
searchRadius <- 0.5

# flag to control highpoint extraction...this is slow (5-6 hours)
doHighPoints <- FALSE

# flag to control use of shifted grid trees
useShiftedTrees <- TRUE

# set the block number (1-4)...loop to do all 4 blocks
#blockNum <- 1
for (blockNum in 1:4) {
  CHM <- paste0(dataFolder, "FUSIONProcessing/", "CHM/CHM.dtm")
  roughCHM <- paste0(dataFolder, "FUSIONProcessing/", "CHM/CHM_NOT_smoothed.dtm")
  
  # load grid trees for block
  if (useShiftedTrees) {
    bt <- vect(paste0(inputFolder, "ShiftedBlock", blockNum, "Trees.shp"))
  } else {
    bt <- vect(paste0(inputFolder, "Block", blockNum, "Trees.shp"))
  }
  
  # build data frame for ID, X, Y
  df <- data.frame(Tag = bt$Tag, X = bt$X, Y = bt$Y)

  # get surface values for highpoint XY locations...unsmoothed CHM
  dfns <- GetSurfaceValues(df, "X", "Y", "CHMroughHt", roughCHM)
  
  bt$CHMroughHt <- dfns$CHMroughHt
  
  # get surface values for highpoint XY locations...smoothed CHM
  dfns <- GetSurfaceValues(df, "X", "Y", "CHMsmthHt", CHM)
  
  bt$CHMsmthHt <- dfns$CHMsmthHt
  
  # step through the trees, clip a small sample, and get the highest point in the
  # sample area
  if (doHighPoints) {
    bt$HighPtHt <- 0
    #tree <- 1
    for (tree in 1:nrow(bt)) {
      # clip small area
      ClipPlot(paste0(dataFolder, "LiDAR/*.laz"), paste0(dataFolder, "Temp.las"), 
               bt$X[tree], bt$Y[tree], searchRadius,
               class = "~7,9,18",
               height = TRUE,
               ground = paste0(dataFolder, "ground/buckhorn2.dtm"))
      
      # compute limited set of metrics and get height max
      CloudMetrics(paste0(dataFolder, "Temp.las"), paste0(dataFolder, "Temp.csv"), highpoint = TRUE, new = TRUE)
      
      # read metrics
      t <- read.csv(paste0(dataFolder, "Temp.csv"), stringsAsFactors = F)
      bt$HighPtHt[tree] <- t$High.point.elevation
    }
    
    unlink(paste0(dataFolder, "Temp.las"))
    unlink(paste0(dataFolder, "Temp.csv"))
  }
  
  # write new trees
  if (useShiftedTrees) {
    writeVector(bt, paste0(outputFolder, "FINAL_ShiftedBlock", blockNum, "_SimpleMeasurements.shp"), overwrite = T)
  } else {
    writeVector(bt, paste0(outputFolder, "FINAL_Block", blockNum, "_SimpleMeasurements.shp"), overwrite = T)
  }
  
  # write data as csv
  if (useShiftedTrees) {
    write.csv(bt, paste0(outputFolder, "FINAL_ShiftedBlock", blockNum, "_SimpleMeasurements.csv"), row.names = F)
  } else {
    write.csv(bt, paste0(outputFolder, "FINAL_Block", blockNum, "_SimpleMeasurements.csv"), row.names = F)
  }
}